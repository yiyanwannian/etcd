@startuml client-sdk-architecture-code
!theme plain
title etcd å®¢æˆ·ç«¯ SDK æ¶æ„å›¾ - ä»£ç å®ç°ä½ç½®

package "å®¢æˆ·ç«¯æ ¸å¿ƒ Client Core" {
  class Client {
    +Cluster
    +KV
    +Lease
    +Watcher
    +Auth
    +Maintenance
    +conn: *grpc.ClientConn
    +cfg: Config
    +resolver: *EtcdManualResolver
    +New()
    +Close()
    --
    ğŸ“ client/v3/client.go:Client
    ğŸ“ client/v3/client.go:New()
    ğŸ“ client/v3/client.go:(*Client).Close()
    ğŸ“ client/v3/client.go:(*Client).dial()
  }
  
  class Config {
    +Endpoints: []string
    +AutoSyncInterval: time.Duration
    +DialTimeout: time.Duration
    +DialKeepAliveTime: time.Duration
    +DialKeepAliveTimeout: time.Duration
    +TLS: *tls.Config
    +Username: string
    +Password: string
    +Logger: *zap.Logger
    --
    ğŸ“ client/v3/config.go:Config
    ğŸ“ client/v3/config.go:(*Config).validate()
  }
}

package "KV æ¥å£ KV Interface" {
  interface KV {
    +Put(): (*PutResponse, error)
    +Get(): (*GetResponse, error)
    +Delete(): (*DeleteResponse, error)
    +Compact(): (*CompactResponse, error)
    +Do(): (OpResponse, error)
    +Txn(): Txn
    --
    ğŸ“ client/v3/kv.go:KV
    ğŸ“ client/v3/kv.go:(*kv).Put()
    ğŸ“ client/v3/kv.go:(*kv).Get()
    ğŸ“ client/v3/kv.go:(*kv).Delete()
    ğŸ“ client/v3/kv.go:(*kv).Do()
  }
  
  class kv {
    +remote: pb.KVClient
    +callOpts: []grpc.CallOption
    --
    ğŸ“ client/v3/kv.go:kv
    ğŸ“ client/v3/kv.go:NewKV()
    ğŸ“ client/v3/kv.go:(*kv).Put()
    ğŸ“ client/v3/kv.go:(*kv).Get()
    ğŸ“ client/v3/kv.go:(*kv).Delete()
  }
  
  interface Txn {
    +If(): Txn
    +Then(): Txn
    +Else(): Txn
    +Commit(): (*TxnResponse, error)
    --
    ğŸ“ client/v3/txn.go:Txn
    ğŸ“ client/v3/txn.go:(*txn).If()
    ğŸ“ client/v3/txn.go:(*txn).Then()
    ğŸ“ client/v3/txn.go:(*txn).Else()
    ğŸ“ client/v3/txn.go:(*txn).Commit()
  }
  
  class txn {
    +kv: *kv
    +cif: bool
    +cthen: bool
    +celse: bool
    +cmps: []*pb.Compare
    +sus: []*pb.RequestOp
    +fas: []*pb.RequestOp
    --
    ğŸ“ client/v3/txn.go:txn
    ğŸ“ client/v3/txn.go:(*txn).If()
    ğŸ“ client/v3/txn.go:(*txn).Then()
    ğŸ“ client/v3/txn.go:(*txn).Else()
  }
}

package "Watch æ¥å£ Watch Interface" {
  interface Watcher {
    +Watch(): WatchChan
    +RequestProgress(): error
    +Close(): error
    --
    ğŸ“ client/v3/watch.go:Watcher
    ğŸ“ client/v3/watch.go:(*watcher).Watch()
    ğŸ“ client/v3/watch.go:(*watcher).RequestProgress()
    ğŸ“ client/v3/watch.go:(*watcher).Close()
  }
  
  class watcher {
    +remote: pb.WatchClient
    +callOpts: []grpc.CallOption
    +mu: sync.RWMutex
    +streams: map[string]*watchGrpcStream
    --
    ğŸ“ client/v3/watch.go:watcher
    ğŸ“ client/v3/watch.go:NewWatcher()
    ğŸ“ client/v3/watch.go:(*watcher).Watch()
    ğŸ“ client/v3/watch.go:(*watcher).newWatcherGrpcStream()
  }
  
  class watchGrpcStream {
    +owner: *watcher
    +remote: pb.Watch_WatchClient
    +watcherStream: chan WatchResponse
    +respc: chan *pb.WatchResponse
    +donec: chan struct{}
    +errc: chan error
    +ctxs: map[int64]*watcherStream
    --
    ğŸ“ client/v3/watch.go:watchGrpcStream
    ğŸ“ client/v3/watch.go:(*watchGrpcStream).run()
    ğŸ“ client/v3/watch.go:(*watchGrpcStream).serv()
    ğŸ“ client/v3/watch.go:(*watchGrpcStream).newWatcherStream()
  }
  
  class WatchResponse {
    +Header: pb.ResponseHeader
    +Events: []*Event
    +CompactRevision: int64
    +Canceled: bool
    +Created: bool
    --
    ğŸ“ client/v3/watch.go:WatchResponse
    ğŸ“ client/v3/watch.go:(*WatchResponse).IsProgressNotify()
  }
}

package "Lease æ¥å£ Lease Interface" {
  interface Lease {
    +Grant(): (*LeaseGrantResponse, error)
    +Revoke(): (*LeaseRevokeResponse, error)
    +TimeToLive(): (*LeaseTimeToLiveResponse, error)
    +Leases(): (*LeaseLeasesResponse, error)
    +KeepAlive(): (<-chan *LeaseKeepAliveResponse, error)
    +KeepAliveOnce(): (*LeaseKeepAliveResponse, error)
    +Close(): error
    --
    ğŸ“ client/v3/lease.go:Lease
    ğŸ“ client/v3/lease.go:(*lessor).Grant()
    ğŸ“ client/v3/lease.go:(*lessor).Revoke()
    ğŸ“ client/v3/lease.go:(*lessor).KeepAlive()
  }
  
  class lessor {
    +remote: pb.LeaseClient
    +callOpts: []grpc.CallOption
    +mu: sync.RWMutex
    +keepAlives: map[LeaseID]*keepAlive
    +firstKeepAliveTimeout: time.Duration
    --
    ğŸ“ client/v3/lease.go:lessor
    ğŸ“ client/v3/lease.go:NewLease()
    ğŸ“ client/v3/lease.go:(*lessor).Grant()
    ğŸ“ client/v3/lease.go:(*lessor).KeepAlive()
    ğŸ“ client/v3/lease.go:(*lessor).keepAliveOnce()
  }
  
  class keepAlive {
    +chs: []chan<- *LeaseKeepAliveResponse
    +ctxs: []context.Context
    +deadline: time.Time
    +nextKeepAlive: time.Time
    +donec: chan struct{}
    --
    ğŸ“ client/v3/lease.go:keepAlive
    ğŸ“ client/v3/lease.go:(*lessor).keepAliveCtxCloser()
    ğŸ“ client/v3/lease.go:(*lessor).recvKeepAlive()
  }
}

package "Auth æ¥å£ Auth Interface" {
  interface Auth {
    +AuthEnable(): (*AuthEnableResponse, error)
    +AuthDisable(): (*AuthDisableResponse, error)
    +Authenticate(): (*AuthenticateResponse, error)
    +UserAdd(): (*AuthUserAddResponse, error)
    +UserDelete(): (*AuthUserDeleteResponse, error)
    +UserChangePassword(): (*AuthUserChangePasswordResponse, error)
    +UserGrantRole(): (*AuthUserGrantRoleResponse, error)
    +UserGet(): (*AuthUserGetResponse, error)
    +UserList(): (*AuthUserListResponse, error)
    +UserRevokeRole(): (*AuthUserRevokeRoleResponse, error)
    +RoleAdd(): (*AuthRoleAddResponse, error)
    +RoleGrantPermission(): (*AuthRoleGrantPermissionResponse, error)
    +RoleGet(): (*AuthRoleGetResponse, error)
    +RoleList(): (*AuthRoleListResponse, error)
    +RoleRevokePermission(): (*AuthRoleRevokePermissionResponse, error)
    +RoleDelete(): (*AuthRoleDeleteResponse, error)
    --
    ğŸ“ client/v3/auth.go:Auth
    ğŸ“ client/v3/auth.go:(*auth).AuthEnable()
    ğŸ“ client/v3/auth.go:(*auth).Authenticate()
    ğŸ“ client/v3/auth.go:(*auth).UserAdd()
    ğŸ“ client/v3/auth.go:(*auth).RoleAdd()
  }
  
  class auth {
    +remote: pb.AuthClient
    +callOpts: []grpc.CallOption
    --
    ğŸ“ client/v3/auth.go:auth
    ğŸ“ client/v3/auth.go:NewAuth()
    ğŸ“ client/v3/auth.go:(*auth).Authenticate()
    ğŸ“ client/v3/auth.go:(*auth).UserAdd()
  }
}

package "è¿æ¥ç®¡ç† Connection Management" {
  class resolver.EtcdManualResolver {
    +endpoints: []string
    +cc: resolver.ClientConn
    +UpdateState()
    +ResolveNow()
    +Close()
    --
    ğŸ“ client/v3/naming/resolver.go:EtcdManualResolver
    ğŸ“ client/v3/naming/resolver.go:(*EtcdManualResolver).UpdateState()
    ğŸ“ client/v3/naming/resolver.go:(*EtcdManualResolver).ResolveNow()
  }
  
  class balancer {
    +endpoints: []string
    +pinAddr: string
    +mu: sync.RWMutex
    +Build()
    +Pick()
    +Close()
    --
    ğŸ“ client/v3/balancer/balancer.go:baseBalancer
    ğŸ“ client/v3/balancer/picker/picker.go:Picker
    ğŸ“ client/v3/balancer/picker/roundrobin.go:rrPicker
  }
  
  class healthBalancer {
    +balancer
    +unhealthyHostPort: map[string]time.Time
    +hostPortError: map[string]error
    +unhealthyMu: sync.RWMutex
    --
    ğŸ“ client/v3/balancer/picker/health.go:healthPicker
    ğŸ“ client/v3/balancer/picker/health.go:(*healthPicker).Pick()
  }
}

package "é‡è¯•æœºåˆ¶ Retry Logic" {
  class retryInterceptor {
    +retryPolicy: retryPolicy
    +UnaryClientInterceptor()
    +StreamClientInterceptor()
    --
    ğŸ“ client/v3/retry.go:retryInterceptor
    ğŸ“ client/v3/retry.go:RetryInterceptor()
    ğŸ“ client/v3/retry.go:unaryClientInterceptor()
    ğŸ“ client/v3/retry.go:streamClientInterceptor()
  }
  
  class retryPolicy {
    +max: int
    +backoff: backoffFunc
    +retryableFunc: retryableFunc
    --
    ğŸ“ client/v3/retry.go:retryPolicy
    ğŸ“ client/v3/retry.go:(*retryPolicy).retryable()
    ğŸ“ client/v3/retry.go:isRetryableError()
  }
}

' å…³ç³»è¿æ¥
Client --> Config : ä½¿ç”¨é…ç½®\nğŸ“ client/v3/config.go
Client --> KV : å®ç°æ¥å£\nğŸ“ client/v3/kv.go
Client --> Watcher : å®ç°æ¥å£\nğŸ“ client/v3/watch.go
Client --> Lease : å®ç°æ¥å£\nğŸ“ client/v3/lease.go
Client --> Auth : å®ç°æ¥å£\nğŸ“ client/v3/auth.go

kv --> KV : å®ç°\nğŸ“ client/v3/kv.go
txn --> Txn : å®ç°\nğŸ“ client/v3/txn.go
kv --> txn : åˆ›å»ºäº‹åŠ¡\nğŸ“ client/v3/kv.go

watcher --> Watcher : å®ç°\nğŸ“ client/v3/watch.go
watcher --> watchGrpcStream : ç®¡ç†æµ\nğŸ“ client/v3/watch.go
watchGrpcStream --> WatchResponse : ç”Ÿæˆå“åº”\nğŸ“ client/v3/watch.go

lessor --> Lease : å®ç°\nğŸ“ client/v3/lease.go
lessor --> keepAlive : ç®¡ç†ç»­çº¦\nğŸ“ client/v3/lease.go

auth --> Auth : å®ç°\nğŸ“ client/v3/auth.go

Client --> resolver.EtcdManualResolver : ä½¿ç”¨è§£æå™¨\nğŸ“ client/v3/naming/
resolver.EtcdManualResolver --> balancer : è´Ÿè½½å‡è¡¡\nğŸ“ client/v3/balancer/
balancer --> healthBalancer : å¥åº·æ£€æŸ¥\nğŸ“ client/v3/balancer/picker/

Client --> retryInterceptor : é‡è¯•æ‹¦æˆªå™¨\nğŸ“ client/v3/retry.go
retryInterceptor --> retryPolicy : é‡è¯•ç­–ç•¥\nğŸ“ client/v3/retry.go

note right of Client
  å®¢æˆ·ç«¯ä¸»å…¥å£å®ç°:
  ğŸ“ client/v3/client.go
  
  å…³é”®æ–¹æ³•:
  - New(): åˆ›å»ºå®¢æˆ·ç«¯å®ä¾‹
  - dial(): å»ºç«‹ gRPC è¿æ¥
  - Close(): å…³é—­å®¢æˆ·ç«¯è¿æ¥
  - Sync(): åŒæ­¥ç«¯ç‚¹åˆ—è¡¨
  
  é…ç½®ç®¡ç†:
  ğŸ“ client/v3/config.go
  - Config: å®¢æˆ·ç«¯é…ç½®ç»“æ„
  - validate(): é…ç½®éªŒè¯
end note

note right of watchGrpcStream
  Watch æµç®¡ç†å®ç°:
  ğŸ“ client/v3/watch.go
  
  æ ¸å¿ƒæ–¹æ³•:
  - run(): ä¸»è¿è¡Œå¾ªç¯
  - serv(): æœåŠ¡å¤„ç†å¾ªç¯
  - newWatcherStream(): åˆ›å»ºç›‘å¬æµ
  - closeWatcherStream(): å…³é—­ç›‘å¬æµ
  
  æµç®¡ç†:
  - ç»´æŠ¤ gRPC åŒå‘æµ
  - å¤„ç†äº‹ä»¶åˆ†å‘
  - ç®¡ç†å¤šä¸ªç›‘å¬å™¨
  - é”™è¯¯å¤„ç†å’Œé‡è¿
end note

note right of keepAlive
  ç§Ÿçº¦ç»­æœŸç®¡ç†å®ç°:
  ğŸ“ client/v3/lease.go
  
  ç»­æœŸæœºåˆ¶:
  - keepAliveCtxCloser(): ä¸Šä¸‹æ–‡å…³é—­å¤„ç†
  - recvKeepAlive(): æ¥æ”¶ç»­æœŸå“åº”
  - sendKeepAliveLoop(): å‘é€ç»­æœŸå¾ªç¯
  
  ç‰¹æ€§:
  - è‡ªåŠ¨ç»­æœŸæœºåˆ¶
  - å¤šé€šé“æ”¯æŒ
  - è¶…æ—¶å¤„ç†
  - ç”Ÿå‘½å‘¨æœŸç®¡ç†
end note

note right of healthBalancer
  å¥åº·æ£€æŸ¥è´Ÿè½½å‡è¡¡å®ç°:
  ğŸ“ client/v3/balancer/picker/health.go
  
  è´Ÿè½½å‡è¡¡ç­–ç•¥:
  ğŸ“ client/v3/balancer/picker/roundrobin.go
  ğŸ“ client/v3/balancer/picker/priority.go
  
  åŠŸèƒ½:
  - ç«¯ç‚¹å¥åº·ç›‘æ§
  - æ•…éšœè½¬ç§»
  - è¿æ¥ç®¡ç†
  - æ€§èƒ½ä¼˜åŒ–
end note

note as N1
  å®¢æˆ·ç«¯åˆå§‹åŒ–æµç¨‹:
  
  1. client/v3/client.go:New()
     â†“
  2. client/v3/client.go:(*Client).dial()
     â†“
  3. client/v3/naming/resolver.go:NewBuilder()
     â†“
  4. client/v3/balancer/balancer.go:newBaseBalancer()
     â†“
  5. client/v3/retry.go:RetryInterceptor()
     â†“
  6. google.golang.org/grpc:DialContext()
  
  æ¥å£åˆ›å»º:
  - NewKV(): KV æ¥å£
  - NewWatcher(): Watch æ¥å£  
  - NewLease(): Lease æ¥å£
  - NewAuth(): Auth æ¥å£
  - NewCluster(): Cluster æ¥å£
  - NewMaintenance(): Maintenance æ¥å£
end note

@enduml
